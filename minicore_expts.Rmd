---
title: "Minicore experiments"
output: html_notebook
---

```{r libs, message=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
```

```{r wd}
setwd('~/git/minicore-experiments')
```

```{r kmpp_parse}
m <- read.table('kmeanspp_exp/kmpp_merged.csv', header=T, sep=',')
m$value <- ifelse(m$value > 1e300, NA, m$value)
```

### First result

* MC and MCLS both faster than SKL
    * Though note that as of 3/8/2021, the results are not really comparable as SKL only uses 1 thread
* MC and MCLS competitive with, usually lower objective than SKL, with MCLS usually the lowest

```{r kmpp_plot}
kmpp_plot <- function(m, distance='SQRL2', nthreads=4, measure='time', kmin=25) {
  m %>%
    filter(distance == !!distance & nthreads == !!nthreads & measure == !!measure & k >= kmin) %>%
    ggplot(aes(x=k, y=value, color=name)) +
      facet_grid(dataset~sparsity, scales='free_y') +
      geom_line() + geom_point() + theme_bw() + labs(y=measure)
}
```

```{r kmpp_time_4t_k25}
kmpp_plot(m)
```

```{r kmpp_time_16t_25}
kmpp_plot(m, nthreads=16)
```

```{r kmpp_time_4t}
kmpp_plot(m, kmin=0)
```

```{r kmpp_time_16t}
kmpp_plot(m, nthreads=16, kmin=0)
```

```{r kmpp_cost_4t_k25}
kmpp_plot(m, measure='cost')
```
```{r kmpp_cost_16t_k25}
kmpp_plot(m, measure='cost', nthreads=16)
```
```{r kmpp_cost_4t}
kmpp_plot(m, measure='cost', kmin=0)
```
```{r kmpp_cost_16t}
kmpp_plot(m, measure='cost', nthreads=16, kmin=0)
```

### Second result

* Even the slowest distance is not _much_ slower than the fastest

```{r kmpp_dist_t16}
m %>% filter(nthreads == 16 & measure == 'time' & name == 'MC_KMpp' & sparsity == 'sparse' & dataset %in% c('Cao2m', 'Cao4m')) %>%
  ggplot(aes(x=as.numeric(k), y=as.numeric(value), color=distance)) + geom_point() + facet_grid(~dataset, scales="free_y")
```

```{r kmpp_dist_t4}
m %>% filter(nthreads == 4 & measure == 'time' & name == 'MC_KMpp' & sparsity == 'sparse' & dataset %in% c('tiny', 'PBMC')) %>%
  ggplot(aes(x=as.numeric(k), y=as.numeric(value), color=distance)) + geom_point() + facet_grid(~dataset, scales="free_y")
```

### Third result

* MC and MCLS both yield better downstream k-means objectives compared to SKL
* Our minibatch k-means handles the various distances
